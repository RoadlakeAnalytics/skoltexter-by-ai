"""School Data Processing Project Setup Script.

Provides an interactive, menu-driven interface for managing the school data processing pipeline.
Supports internationalized UI (English/Swedish), Python virtual environment management, dependency installation,
program description viewing, step-by-step pipeline execution, and log file inspection.

Features:
    1. Select UI language (English/Swedish).
    2. Manage Python virtual environment and install dependencies (can be skipped with --no-venv).
    3. Display descriptions of the project's programs.
    4. Run the data processing and website generation pipeline step-by-step.
    5. View log files generated by the programs.

Command-line options:
    --lang      Set UI language (en or sv).
    --no-venv   Skip virtual environment creation and dependency installation.

All internal comments are in English. UI text is internationalized.

When run interactively, presents a menu to create a virtual environment or continue without one.
Both choices are valid and supported. The --no-venv CLI flag works for automation, bypassing the menu.
"""

import sys
import subprocess
import venv
import shutil
import argparse
import logging
import os
from pathlib import Path
from typing import Any, Dict, List
import re

from src.config import (
    PROJECT_ROOT,
    SRC_DIR,
    VENV_DIR,
    LOG_DIR,
    REQUIREMENTS_FILE,
    LANG as DEFAULT_LANG,
)

# --- Platform-specific virtual environment path helpers ---
def get_venv_bin_dir(venv_path: Path) -> Path:
    """Return the bin/Scripts directory for a virtual environment based on platform.
    
    Args:
        venv_path (Path): Path to the virtual environment directory
        
    Returns:
        Path: The bin directory on Unix/Linux/macOS or Scripts directory on Windows
    """
    if sys.platform == "win32":
        return venv_path / "Scripts"
    else:
        return venv_path / "bin"

def get_venv_python_executable(venv_path: Path) -> Path:
    """Return the Python executable path for a virtual environment based on platform.
    
    Args:
        venv_path (Path): Path to the virtual environment directory
        
    Returns:
        Path: The Python executable path (python.exe on Windows, python on Unix)
    """
    bin_dir = get_venv_bin_dir(venv_path)
    if sys.platform == "win32":
        return bin_dir / "python.exe"
    else:
        return bin_dir / "python"

def get_venv_pip_executable(venv_path: Path) -> Path:
    """Return the pip executable path for a virtual environment based on platform.
    
    Args:
        venv_path (Path): Path to the virtual environment directory
        
    Returns:
        Path: The pip executable path (pip.exe on Windows, pip on Unix)
    """
    bin_dir = get_venv_bin_dir(venv_path)
    if sys.platform == "win32":
        return bin_dir / "pip.exe"
    else:
        return bin_dir / "pip"

# --- Logging Setup ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(module)s - %(funcName)s - %(message)s"
)
logger = logging.getLogger(__name__)

# --- Azure OpenAI .env Setup Constants ---
ENV_PATH = Path(".env")
ENV_EXAMPLE_PATH = Path(".env-example")
REQUIRED_AZURE_KEYS = [
    "AZURE_API_KEY",
    "AZURE_ENDPOINT_BASE",
    "GPT4O_DEPLOYMENT_NAME",
    "AZURE_API_VERSION",
]
ENV_KEY_VALUE_PATTERN = re.compile(r'^\s*([A-Z0-9_]+)\s*=\s*["\']?(.*?)["\']?\s*$')

# --- Internationalization (i18n) ---
TEXTS = {
    "en": {
        "welcome": "Welcome to the School Data Processing Project Setup!",
        "language_prompt": "Select language (1 for English, 2 for Svenska): ",
        "invalid_choice": "Invalid choice. Please try again.",
        "venv_active": "A virtual environment is already active: ",
        "venv_exists": f"Virtual environment '{VENV_DIR.name}' already exists.",
        "venv_menu_title": "\n--- Virtual Environment Setup ---",
        "venv_menu_option_1": "1. Create a virtual environment and install dependencies",
        "venv_menu_option_2": "2. Continue without a virtual environment",
        "venv_menu_prompt": "Choose an option (1 or 2): ",
        "venv_menu_info": "",
        "create_venv_prompt": f"Create/recreate and install dependencies? (y/n, default y): ",
        "activate_venv_prompt": f"Virtual environment '{VENV_DIR.name}' exists. Install/update dependencies? (y/n, default y): ",
        "no_venv_prompt": f"No virtual environment found. Create '{VENV_DIR.name}' and install dependencies? (y/n, default y): ",
        "creating_venv": "Creating virtual environment...",
        "installing_deps": "Installing dependencies...",
        "deps_installed": "Dependencies installed.",
        "deps_install_failed": "Failed to install dependencies.",
        "venv_ready": "Virtual environment is set up.",
        "venv_skipped": "Virtual environment setup skipped.",
        "main_menu_title": "\n--- Main Menu ---",
        "menu_option_1": "1. Manage Virtual Environment & Dependencies",
        "menu_option_2": "2. View Program Descriptions",
        "menu_option_3": "3. Run Processing Pipeline",
        "menu_option_4": "4. View Logs",
        "menu_option_5": "5. Reset Project",
        "menu_option_6": "6. Exit",
        "enter_choice": "Enter your choice: ",
        "program_descriptions_title": "\n--- Program Descriptions ---",
        "program_1_desc_short": "Program 1 (Generate Markdowns from CSV)",
        "program_1_desc_long": (
            "Reads school data from the main CSV file and uses a template "
            "to generate individual markdown files for each school."
        ),
        "program_2_desc_short": "Program 2 (AI Processor for School Descriptions)",
        "program_2_desc_long": (
            "Takes the markdown files from Program 1 and sends their content to an "
            "AI service. The AI generates more detailed school descriptions."
        ),
        "program_3_desc_short": "Program 3 (Generate Website)",
        "program_3_desc_long": (
            "Loads school names from the CSV and their AI-generated descriptions "
            "and generates a standalone HTML file."
        ),
        "select_program_to_describe": "Select program to describe (1, 2, 3, or 0 to return): ",
        "pipeline_title": "\n--- Run Processing Pipeline ---",
        "pipeline_skip_info": "",
        "run_program_1_prompt": "Run Program 1? (y/n/s, default y): ",
        "running_program_1": "Running Program 1...",
        "program_1_complete": "Program 1 completed.",
        "program_1_failed": "Program 1 failed or was skipped.",
        "run_program_2_prompt": "Run Program 2? (y/n/s, default y): ",
        "running_program_2": "Running Program 2...",
        "program_2_complete": "Program 2 completed.",
        "program_2_failed": "Program 2 failed or was skipped.",
        "program_2_skipped": "Program 2 skipped.",
        "run_program_3_prompt": "Run Program 3? (y/n/s, default y): ",
        "running_program_3": "Running Program 3...",
        "program_3_complete": "Program 3 completed.",
        "program_3_failed": "Program 3 failed or was skipped.",
        "pipeline_complete": "Processing pipeline finished.",
        "logs_title": "\n--- View Logs ---",
        "no_logs": f"No log files found in {LOG_DIR}",
        "select_log_prompt": "Enter the log file name to view (or 0 to return): ",
        "viewing_log": "Viewing log: ",
        "log_not_found": "Log file not found.",
        "exiting": "Exiting setup script.",
        "confirm_recreate_venv": f"WARNING: '{VENV_DIR.name}' exists. Recreate? (y/n, default n): ",
        "return_to_menu": "Return to Main Menu",
        "reset_option": "6. Reset Project",
        "reset_confirm": "Delete ALL generated files? (y/n, default n): ",
        "reset_complete": "Project reset completed.",
        "reset_cancelled": "Reset cancelled.",
        "azure_env_intro": "The following Azure OpenAI values are required for local storage so the program can call Azure OpenAI.",
        "azure_env_storage": "They will be stored in the .env file. These values are only needed for local storage and are not shared.",
        "azure_env_prompt": "Enter value for {key}: "
    },
    "sv": {
        "welcome": "Välkommen till installationsprogrammet för skoldata!",
        "language_prompt": "Välj språk (1 för Engelska, 2 för Svenska): ",
        "invalid_choice": "Ogiltigt val. Försök igen.",
        "venv_active": "En virtuell miljö är redan aktiv: ",
        "venv_exists": f"Virtuell miljö '{VENV_DIR.name}' finns redan.",
        "venv_menu_title": "\n--- Virtuell Miljö ---",
        "venv_menu_option_1": "1. Skapa virtuell miljö och installera beroenden",
        "venv_menu_option_2": "2. Fortsätt utan virtuell miljö",
        "venv_menu_prompt": "Välj ett alternativ (1 eller 2): ",
        "venv_menu_info": "",
        "create_venv_prompt": f"Skapa/återskapa och installera beroenden? (y/n, standard y): ",
        "activate_venv_prompt": f"Virtuell miljö '{VENV_DIR.name}' finns. Installera/uppdatera beroenden? (y/n, standard y): ",
        "no_venv_prompt": f"Ingen virtuell miljö hittades. Skapa '{VENV_DIR.name}' och installera beroenden? (y/n, standard y): ",
        "creating_venv": "Skapar virtuell miljö...",
        "installing_deps": "Installerar beroenden...",
        "deps_installed": "Beroenden installerade.",
        "deps_install_failed": "Misslyckades installera beroenden.",
        "venv_ready": "Virtuell miljö är klar.",
        "venv_skipped": "Virtuell miljö hoppades över.",
        "main_menu_title": "\n--- Huvudmeny ---",
        "menu_option_1": "1. Hantera virtuell miljö & beroenden",
        "menu_option_2": "2. Visa programbeskrivningar",
        "menu_option_3": "3. Kör bearbetningsflöde",
        "menu_option_4": "4. Visa loggar",
        "menu_option_5": "5. Återställ projekt",
        "menu_option_6": "6. Avsluta",
        "enter_choice": "Ange ditt val: ",
        "program_descriptions_title": "\n--- Programbeskrivningar ---",
        "program_1_desc_short": "Program 1 (Generera markdown från CSV)",
        "program_1_desc_long": (
            "Läser skoldata från huvud-CSV och använder en mall "
            "för att skapa individuella markdown-filer för varje skola."
        ),
        "program_2_desc_short": "Program 2 (AI-processor för skolbeskrivningar)",
        "program_2_desc_long": (
            "Tar markdown-filer från Program 1 och skickar innehållet till en "
            "AI-tjänst. AI genererar mer detaljerade skolbeskrivningar."
        ),
        "program_3_desc_short": "Program 3 (Generera webbplats)",
        "program_3_desc_long": (
            "Laddar skolnamn från CSV och deras AI-genererade beskrivningar "
            "och skapar en fristående HTML-fil."
        ),
        "select_program_to_describe": "Välj program att beskriva (1, 2, 3, eller 0 för att återgå): ",
        "pipeline_title": "\n--- Kör bearbetningsflöde ---",
        "pipeline_skip_info": "",
        "run_program_1_prompt": "Kör Program 1? (y/n/s, standard y): ",
        "running_program_1": "Kör Program 1...",
        "program_1_complete": "Program 1 klar.",
        "program_1_failed": "Program 1 misslyckades eller hoppade över.",
        "run_program_2_prompt": "Kör Program 2? (y/n/s, standard y): ",
        "running_program_2": "Kör Program 2...",
        "program_2_complete": "Program 2 klar.",
        "program_2_failed": "Program 2 misslyckades eller hoppade över.",
        "program_2_skipped": "Program 2 hoppade över.",
        "run_program_3_prompt": "Kör Program 3? (y/n/s, standard y): ",
        "running_program_3": "Kör Program 3...",
        "program_3_complete": "Program 3 klar.",
        "program_3_failed": "Program 3 misslyckades eller hoppade över.",
        "pipeline_complete": "Bearbetningsflöde klart.",
        "logs_title": "\n--- Visa loggar ---",
        "no_logs": f"Inga loggfiler hittades i {LOG_DIR}",
        "select_log_prompt": "Ange loggfilens namn att visa (eller 0 för att återgå): ",
        "viewing_log": "Visar logg: ",
        "log_not_found": "Loggfil hittades inte.",
        "exiting": "Avslutar installationsprogrammet.",
        "confirm_recreate_venv": f"VARNING: '{VENV_DIR.name}' finns. Återskapa? (y/n, standard n): ",
        "return_to_menu": "Återgå till huvudmenyn",
        "reset_option": "6. Återställ projekt",
        "reset_confirm": "Radera ALLA genererade filer? (y/n, standard n): ",
        "reset_complete": "Projektet återställt.",
        "reset_cancelled": "Återställning avbröts.",
        "azure_env_intro": "Följande Azure OpenAI-värden krävs för lokal lagring så att programmet kan använda Azure OpenAI.",
        "azure_env_storage": "De sparas i .env-filen. Dessa värden behövs endast för lokal lagring och delas inte.",
        "azure_env_prompt": "Ange värde för {key}: "
    },
}
LANG = DEFAULT_LANG

def translate(text_key: str) -> str:
    """Return the localized string for the current language.

    Args:
        text_key (str): The key for the text string to look up.

    Returns:
        str: The localized string for the current language, or the English fallback if not found.
    """
    if LANG not in TEXTS:
        logger.warning(f"Unsupported language '{LANG}' selected. Falling back to English.")
        return TEXTS["en"].get(text_key, text_key)
    return TEXTS[LANG].get(text_key, TEXTS["en"].get(text_key, text_key))

LANG = DEFAULT_LANG

def _(text_key: str) -> str:
    """Return the localized string for the current language (alias for translate).

    Args:
        text_key (str): The key for the text string to look up.

    Returns:
        str: The localized string for the current language, or the English fallback if not found.
    """
    if LANG not in TEXTS:
        logger.warning(f"Unsupported language '{LANG}' selected. Falling back to English.")
        return TEXTS["en"].get(text_key, text_key)
    return TEXTS[LANG].get(text_key, TEXTS["en"].get(text_key, text_key))

def set_language() -> None:
    """Prompt the user to select a UI language and update the global LANG variable.

    Prompts the user to choose a language for the UI. Updates the global LANG variable
    accordingly. Exits the program on keyboard interrupt.

    Returns:
        None
    """
    global LANG
    while True:
        try:
            choice = input(TEXTS["en"]["language_prompt"])
            if choice == "1":
                LANG = "en"
                break
            if choice == "2":
                LANG = "sv"
                break
            print(TEXTS["en"]["invalid_choice"])
        except KeyboardInterrupt:
            print(TEXTS["en"]["exiting"])
            sys.exit(0)
        except Exception:
            print(TEXTS["en"]["invalid_choice"])
    if LANG not in TEXTS:
        LANG = "en"

def is_venv_active() -> bool:
    """Return True if a Python virtual environment is currently active.

    Returns:
        bool: True if a virtual environment is active, False otherwise.
    """
    return hasattr(sys, 'prefix') and sys.prefix != sys.base_prefix

def get_python_executable() -> str:
    """Return the path to the Python executable for the current environment.

    Returns:
        str: Path to the Python executable in the active virtual environment,
        the project's venv if it exists, or the system Python otherwise.
    """
    if is_venv_active():
        return sys.executable
    venv_python = get_venv_python_executable(VENV_DIR)
    if venv_python.exists():
        return str(venv_python)
    return sys.executable

def manage_virtual_environment() -> None:
    """Create, activate, or recreate a virtual environment and install dependencies.

    Prompts the user to create, activate, or recreate a Python virtual environment.
    Installs dependencies from REQUIREMENTS_FILE. Handles user input, logs errors,
    and prints status messages.

    Returns:
        None
    """
    pip_executable = ""
    python_executable = ""
    if is_venv_active():
        pip_executable = get_venv_pip_executable(Path(sys.prefix))
        python_executable = get_venv_python_executable(Path(sys.prefix))
        prompt_text = _("activate_venv_prompt")
        default_choice = 'y'
    elif VENV_DIR.exists():
        pip_executable = get_venv_pip_executable(VENV_DIR)
        python_executable = get_venv_python_executable(VENV_DIR)
        prompt_text = _("create_venv_prompt")
        default_choice = 'y'
    else:
        prompt_text = _("no_venv_prompt")
        default_choice = 'y'
    choice = input(prompt_text).strip().lower() or default_choice
    if choice not in ['y', 'j']:
        print(_("venv_skipped"))
        return
    if not is_venv_active() and VENV_DIR.exists():
        recreate_choice = input(_("confirm_recreate_venv")).strip().lower() or 'n'
        if recreate_choice in ['y', 'j']:
            try:
                shutil.rmtree(VENV_DIR)
            except Exception as error:
                logger.error(f"Error removing venv: {error}")
                return
        elif choice not in ['y', 'j']:
            pass
        else:
            print(_("venv_skipped"))
            return
    if not is_venv_active() and not VENV_DIR.exists():
        print(_("creating_venv"))
        try:
            venv.create(VENV_DIR, with_pip=True)
            pip_executable = get_venv_pip_executable(VENV_DIR)
            python_executable = get_venv_python_executable(VENV_DIR)
        except Exception as error:
            logger.error(f"Error creating virtual environment: {error}")
            return
    if not pip_executable or not Path(pip_executable).exists():
        pip_executable = get_venv_pip_executable(VENV_DIR) if VENV_DIR.exists() else "pip"
    
    # Determine Python executable to use for pip commands
    pip_python = None
    if python_executable and Path(str(python_executable)).exists():
        pip_python = str(python_executable)
    elif is_venv_active():
        pip_python = sys.executable
    elif VENV_DIR.exists():
        venv_python = get_venv_python_executable(VENV_DIR)
        if venv_python.exists():
            pip_python = str(venv_python)
    
    # Fallback to system Python if nothing else works
    if not pip_python:
        pip_python = sys.executable
    
    print(_("installing_deps"))
    try:
        # Use python -m pip instead of direct pip to avoid Windows issues
        subprocess.check_call([pip_python, "-m", "pip", "install", "--upgrade", "pip"])
        subprocess.check_call([pip_python, "-m", "pip", "install", "-r", str(REQUIREMENTS_FILE)])
        print(_("deps_installed"))
        print(_("venv_ready"))
    except subprocess.CalledProcessError as error:
        logger.error(f"{_('deps_install_failed')} Error: {error}")
    except FileNotFoundError:
        logger.error(f"Error: {pip_python} or {REQUIREMENTS_FILE} not found.")

def run_program(program_name: str, program_file: Path, stream_output: bool = False) -> bool:
    """Run a specified program script as a subprocess with language and log level.

    Args:
        program_name (str): The name of the program (for logging and i18n).
        program_file (Path): The path to the program script.
        stream_output (bool, optional): If True, stream stdout/stderr to user in real time. Defaults to False.

    Returns:
        bool: True if the program ran successfully, False otherwise.

    Side Effects:
        Logs messages, prints output, and may stream subprocess output to the console.
    """
    import os

    python_executable = get_python_executable()
    logger.info(f"{_(program_name)} ({program_file.name})...")

    # Pass language and log level to subprocess
    lang_arg = f"--lang={LANG}"
    log_level_arg = "--log-level=INFO"
    module_name = (
        f"src.{program_file.stem}"
        if program_file.parent.name == "src"
        else program_file.with_suffix('').as_posix().replace('/', '.')
    )
    env = os.environ.copy()
    env["LANG_UI"] = LANG

    try:
        if stream_output:
            # Stream output in real time
            process = subprocess.Popen(
                [python_executable, "-m", module_name, lang_arg, log_level_arg],
                cwd=PROJECT_ROOT,
                env=env,
                text=True,
                stdout=sys.stdout,
                stderr=sys.stderr,
            )
            return_code = process.wait()
            if return_code == 0:
                logger.info(_(f"{program_name.lower().replace(' ', '_')}_complete"))
                return True
            fail_key_str = f"{program_name.lower().replace(' ', '_')}_failed"
            logger.error(f"{_(fail_key_str)} (Return code: {return_code})")
            return False
        else:
            process = subprocess.run(
                [python_executable, "-m", module_name, lang_arg, log_level_arg],
                cwd=PROJECT_ROOT,
                check=False,
                capture_output=True,
                text=True,
                env=env,
            )
            if process.returncode == 0:
                logger.info(_(f"{program_name.lower().replace(' ', '_')}_complete"))
                return True
            fail_key_str = f"{program_name.lower().replace(' ', '_')}_failed"
            logger.error(f"{_(fail_key_str)} (Return code: {process.returncode})")
            logger.error("Subprocess output:\n" + (process.stdout or "") + (process.stderr or ""))
            return False
    except Exception as error:
        logger.error(f"Error running {program_file.name}: {error}")
        return False

def get_program_descriptions() -> dict:
    """Return a dictionary of program descriptions for the current language.

    Returns:
        dict: Mapping of program numbers (str) to tuples of (short description, long description).
    """
    return {
        "1": (translate("program_1_desc_short"), translate("program_1_desc_long")),
        "2": (translate("program_2_desc_short"), translate("program_2_desc_long")),
        "3": (translate("program_3_desc_short"), translate("program_3_desc_long")),
    }

def view_program_descriptions() -> None:
    """Display and interactively describe each program in the project.

    Prompts the user to select a program and displays its short and long description.
    Allows returning to the main menu.

    Returns:
        None
    """
    print(translate("program_descriptions_title"))
    while True:
        descriptions = get_program_descriptions()
        for key, (short_desc, _) in descriptions.items():
            print(f"{key}. {short_desc}")
        print("0. " + translate("return_to_menu"))
        choice = input(translate("select_program_to_describe")).strip()
        if choice == "0":
            break
        if choice in descriptions:
            print(f"\n--- {descriptions[choice][0]} ---")
            print(descriptions[choice][1])
            print("-" * (len(descriptions[choice][0]) + 8) + "\n")
        else:
            print(translate("invalid_choice"))

def run_processing_pipeline() -> None:
    """Run the main data processing programs sequentially with user confirmation.

    Executes each processing step in order, prompting the user for confirmation and
    providing localized feedback. Displays a message about opening the generated HTML file.

    Returns:
        None
    """
    print(_("pipeline_title"))
    if not _run_pipeline_step(
        "run_program_1_prompt",
        "program_1",
        SRC_DIR / "program1_generate_markdowns.py",
        "program_1_failed",
        "markdown_created"
    ):
        return
    _run_pipeline_step(
        "run_program_2_prompt",
        "program_2",
        SRC_DIR / "program2_ai_processor.py",
        "program_2_failed",
        "ai_descriptions_created",
        skip_message="program_2_skipped",
        stream_output=True
    )
    program3_success = _run_pipeline_step(
        "run_program_3_prompt",
        "program_3",
        SRC_DIR / "program3_generate_website.py",
        "program_3_failed",
        "website_created"
    )
    print(_("pipeline_complete"))
    # After website generation, display localized message about opening the HTML file
    if program3_success:
        html_path = PROJECT_ROOT / "output" / "index.html"
        open_msg = {
            "en": f"\nOpen the file in your browser by double-clicking it in your file explorer:\n  {html_path.resolve()}",
            "sv": f"\nÖppna filen i din webbläsare genom att dubbelklicka på den i Utforskaren:\n  {html_path.resolve()}",
        }
        print(open_msg.get(LANG, open_msg["en"]))

from typing import Optional

def _run_pipeline_step(
    prompt_key: str,
    program_name: str,
    program_path: Path,
    fail_key: str,
    confirmation_key: str,
    skip_message: Optional[str] = None,
    stream_output: bool = False
) -> bool:
    """Run a single pipeline step with user confirmation and localized feedback.

    Args:
        prompt_key (str): Localization key for the user prompt.
        program_name (str): Name of the program to run.
        program_path (Path): Path to the program script.
        fail_key (str): Localization key for failure message.
        confirmation_key (str): Localization key for confirmation message.
        skip_message (Optional[str], optional): Localization key for skip message. Defaults to None.
        stream_output (bool, optional): If True, stream output in real time. Defaults to False.

    Returns:
        bool: True if the step succeeded, False otherwise.
    """
    choice = input(_(prompt_key)).strip().lower() or 'y'
    if choice in ['y', 'j']:
        if not run_program(program_name, program_path, stream_output=stream_output):
            logger.error(_(fail_key) + " Aborting pipeline.")
            return False
        print(_(confirmation_key))
    elif choice in ['s', 'skip', 'h', 'hoppa']:
        if skip_message:
            print(_(skip_message))
        else:
            print(_(fail_key))
    else:
        print(_(fail_key))
        return False
    return True

def view_logs() -> None:
    """List available log files and allow the user to view them.

    Prompts the user to select a log file to view, or to return to the previous menu.
    Handles file I/O and logs errors.

    Returns:
        None
    """
    print(translate("logs_title"))
    if not LOG_DIR.exists() or not any(LOG_DIR.iterdir()):
        print(translate("no_logs"))
        return
    log_files = sorted([file_path for file_path in LOG_DIR.iterdir() if file_path.is_file() and file_path.name.endswith(".log")])
    if not log_files:
        print(translate("no_logs"))
        return

    while True:
        print(translate("logs_title"))
        for log_number, log_file in enumerate(log_files, start=1):
            print(f"{log_number}. {log_file.name}")
        print(f"0. {translate('return_to_menu')}")
        try:
            choice = input(translate("select_log_prompt")).strip()
            if choice == "0":
                break
            # Allow selection by number or filename
            selected_log = None
            if choice.isdigit():
                log_index = int(choice) - 1
                if 0 <= log_index < len(log_files):
                    selected_log = log_files[log_index]
            if not selected_log:
                selected_log = next((file_path for file_path in log_files if file_path.name == choice or file_path.name.startswith(choice)), None)
            if selected_log:
                print(f"\n--- {translate('viewing_log')}{selected_log.name} ---")
                with selected_log.open("r", encoding="utf-8") as file_handle:
                    print(file_handle.read())
                print(f"--- End of {selected_log.name} ---\n")
            else:
                print(translate("invalid_choice"))
        except Exception as error:
            logger.error(f"Error reading log file: {error}")

def reset_project() -> None:
    """Delete all generated files and directories for a clean project reset.

    Prompts the user for confirmation before deleting generated files and directories.
    Handles file and directory deletion, prints status messages, and logs errors.

    Returns:
        None
    """
    print("\n--- " + translate("menu_option_5").split(". ")[1] + " ---")
    dirs_to_check = [
        PROJECT_ROOT / "data" / "generated_markdown_from_csv",
        PROJECT_ROOT / "data" / "ai_processed_markdown",
        PROJECT_ROOT / "data" / "ai_raw_responses",
        PROJECT_ROOT / "data" / "generated_descriptions",
        PROJECT_ROOT / "output",
        LOG_DIR
    ]
    files_found = []
    for dir_path in dirs_to_check:
        if dir_path.exists():
            files_found.extend([file_path for file_path in dir_path.rglob("*") if file_path.is_file()])
    if not files_found:
        print("No generated files found to delete.")
        return
    print(f"Found {len(files_found)} generated files that will be deleted.")
    print("Directories that will be cleared:")
    for dir_path in dirs_to_check:
        if dir_path.exists() and any(dir_path.rglob("*")):
            print(f"  - {dir_path.relative_to(PROJECT_ROOT)}")
    confirm = input(translate("reset_confirm")).strip().lower() or 'n'
    if confirm not in ['y', 'j']:
        print(translate("reset_cancelled"))
        return
    deleted_count = 0
    for dir_path in dirs_to_check:
        if dir_path.exists():
            for file_path in dir_path.rglob("*"):
                if file_path.is_file():
                    try:
                        file_path.unlink()
                        deleted_count += 1
                    except Exception as error:
                        logger.error(f"Error deleting {file_path}: {error}")
            for dir_path_nested in sorted(dir_path.rglob("*"), reverse=True):
                if dir_path_nested.is_dir() and not any(dir_path_nested.iterdir()):
                    try:
                        dir_path_nested.rmdir()
                    except Exception as error:
                        logger.error(f"Error removing directory {dir_path_nested}: {error}")
    print(f"{translate('reset_complete')} ({deleted_count} files deleted)")

def main_menu() -> None:
    """Display the main menu and handle user choices interactively.

    Presents the user with menu options for environment management, program descriptions,
    running the processing pipeline, viewing logs, resetting the project, or exiting.

    Returns:
        None
    """
    while True:
        print(translate("main_menu_title"))
        print(translate("menu_option_1"))
        print(translate("menu_option_2"))
        print(translate("menu_option_3"))
        print(translate("menu_option_4"))
        print(translate("menu_option_5"))
        print(translate("menu_option_6"))
        choice = input(translate("enter_choice")).strip()
        if choice == "1":
            manage_virtual_environment()
        elif choice == "2":
            view_program_descriptions()
        elif choice == "3":
            run_processing_pipeline()
        elif choice == "4":
            view_logs()
        elif choice == "5":
            reset_project()
        elif choice == "6":
            print(translate("exiting"))
            break
        else:
            print(translate("invalid_choice"))

def parse_cli_args() -> argparse.Namespace:
    """Parse command-line arguments for the setup script.

    Returns:
        argparse.Namespace: Parsed arguments with options for language and venv control.
    """
    parser = argparse.ArgumentParser(
        description=(
            "School Data Processing Project Setup.\n"
            "When run interactively, you will be presented with a menu to either create a virtual environment or continue without one.\n"
            "Both choices are valid and supported. Use --no-venv to skip the menu and venv setup for automation."
        )
    )
    parser.add_argument(
        "--lang",
        type=str,
        choices=["en", "sv"],
        help="UI language (en or sv)"
    )
    parser.add_argument(
        "--no-venv",
        action="store_true",
        help="Skip virtual environment creation and dependency installation (bypasses the interactive menu)"
    )
    return parser.parse_args()

def prompt_virtual_environment_choice() -> bool:
    """Prompt the user to choose between creating a venv or continuing without one.

    Returns:
        bool: True if the user chooses to create a virtual environment, False otherwise.
    """
    print(translate("venv_menu_title"))
    print(translate("venv_menu_option_1"))
    print(translate("venv_menu_option_2"))
    while True:
        choice = input(translate("venv_menu_prompt")).strip()
        if choice == "1":
            return True
        if choice == "2":
            print(translate("venv_skipped"))
            return False
        print(translate("invalid_choice"))

def parse_env_file(env_path: Path) -> Dict[str, str]:
    """Parse a .env-style file into a dictionary of environment variables.

    Args:
        env_path (Path): Path to the .env file.

    Returns:
        Dict[str, str]: Dictionary of environment variable keys and their values.
    """
    env_dict: Dict[str, str] = {}
    if not env_path.exists():
        return env_dict
    with env_path.open("r", encoding="utf-8") as env_file:
        for line in env_file:
            match = ENV_KEY_VALUE_PATTERN.match(line)
            if match:
                key, value = match.groups()
                env_dict[key] = value
    return env_dict


def find_missing_env_keys(existing: Dict[str, str], required: List[str]) -> List[str]:
    """Return required keys that are missing or empty in the existing .env dictionary.

    Args:
        existing (Dict[str, str]): Dictionary of current .env key-value pairs.
        required (List[str]): List of required keys.

    Returns:
        List[str]: List of missing or empty keys.
    """
    return [key for key in required if not existing.get(key)]


def prompt_and_update_env(
    missing_keys: List[str], env_path: Path, existing: Dict[str, str]
) -> None:
    """Prompt the user for missing Azure OpenAI values and update the .env file.

    Args:
        missing_keys (List[str]): List of missing or empty keys.
        env_path (Path): Path to the .env file.
        existing (Dict[str, str]): Dictionary of current .env key-value pairs.

    Returns:
        None
    """
    print(f"\n{_('azure_env_intro')}\n{_('azure_env_storage')}")
    for key in missing_keys:
        prompt = _('azure_env_prompt').format(key=key)
        value = ""
        while not value:
            value = input(prompt).strip()
        existing[key] = value

    # Write all required keys (preserve order), plus any other existing keys
    updated_lines = []
    for key in REQUIRED_AZURE_KEYS:
        updated_lines.append(f'{key}="{existing[key]}"\n')
    # Add any extra keys that were present in the original .env
    for key, value in existing.items():
        if key not in REQUIRED_AZURE_KEYS:
            updated_lines.append(f'{key}="{value}"\n')
    with env_path.open("w", encoding="utf-8") as env_file:
        env_file.writelines(updated_lines)
    logger.info(f"Updated {env_path} with Azure OpenAI values.")


def ensure_azure_openai_env() -> None:
    """Ensure all required Azure OpenAI values are present in .env, prompting the user if needed.

    Returns:
        None
    """
    # Use .env-example as the source of required keys (already in REQUIRED_AZURE_KEYS)
    env_dict = parse_env_file(ENV_PATH)
    missing_keys = find_missing_env_keys(env_dict, REQUIRED_AZURE_KEYS)
    if missing_keys:
        prompt_and_update_env(missing_keys, ENV_PATH, env_dict)
    else:
        logger.info("All required Azure OpenAI values are present in .env.")


if __name__ == "__main__":
    args = parse_cli_args()
    if args.lang:
        if args.lang in TEXTS:
            LANG = args.lang
        else:
            LANG = "en"
    set_language()
    print(translate("welcome"))
    if not args.no_venv:
        if not is_venv_active():
            if prompt_virtual_environment_choice():
                manage_virtual_environment()
    ensure_azure_openai_env()
    main_menu()
    sys.exit(0)
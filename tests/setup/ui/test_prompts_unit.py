"""Consolidated unit tests for src.src/setup/ui/prompts.py

This file was autogenerated by a repository consolidation script.
Original test files:
 - tests/setup/ui/test_prompts_unit.py
 - tests/setup/ui/test_prompts_extra_unit.py
"""


import builtins
import sys
from types import SimpleNamespace
import src.setup.ui.prompts as prom
import pytest

### BEGIN ORIGINAL: tests/setup/ui/test_prompts_unit.py
def test_ask_text_fallback(monkeypatch):
    monkeypatch.setattr(builtins, "input", lambda prompt="": "hello")
    monkeypatch.setattr(prom, "_orch", None, raising=False)
    monkeypatch.setattr(prom.ch, "_HAS_Q", False)
    monkeypatch.setattr(prom.ch, "questionary", None)
    assert prom.ask_text("?") == "hello"


def test_ask_text_questionary(monkeypatch):
    # Ensure orchestrator TUI mode does not interfere with this test by
    # installing a lightweight dummy module into sys.modules so the
    # local import inside `ask_text` resolves to a non-TUI stub.
    # Ensure any previously imported orchestrator module is replaced
    # both in `sys.modules` and as an attribute on the package so the
    # local import inside `ask_text` reliably resolves to our stub.
    import importlib

    pkg = importlib.import_module("src.setup.pipeline")
    stub = SimpleNamespace(_TUI_MODE=False, _TUI_UPDATER=None)
    monkeypatch.setattr(pkg, "orchestrator", stub, raising=False)
    monkeypatch.setitem(sys.modules, "src.setup.pipeline.orchestrator", stub)
    class Q:
        @staticmethod
        def text(prompt, default=""):
            return SimpleNamespace(ask=lambda: "value")

    monkeypatch.setattr(prom.ch, "_HAS_Q", True)
    monkeypatch.setattr(prom.ch, "questionary", Q)
    assert prom.ask_text("?") == "value"


def test_ask_confirm_defaults(monkeypatch):
    monkeypatch.setattr(builtins, "input", lambda prompt="": "")
    monkeypatch.setattr(prom.ch, "_HAS_Q", False)
    monkeypatch.setattr(prom.ch, "questionary", None)
    assert prom.ask_confirm("?") is True
    monkeypatch.setattr(builtins, "input", lambda prompt="": "n")
    assert prom.ask_confirm("?") is False


def test_ask_select_numeric(monkeypatch):
    choices = ["A", "B", "C"]
    # Ensure questionary is not used for this test; force fallback
    monkeypatch.setattr(prom.ch, "_HAS_Q", False)
    monkeypatch.setattr(prom.ch, "questionary", None)
    monkeypatch.setattr(builtins, "input", lambda prompt="": "2")
    assert prom.ask_select("Pick", choices) == "B"


def test_ask_text_questionary_raises_fallback(monkeypatch):
    class Q:
        @staticmethod
        def text(prompt, default=""):
            return SimpleNamespace(ask=lambda: (_ for _ in ()).throw(RuntimeError("boom")))

    monkeypatch.setattr(prom.ch, "_HAS_Q", True)
    monkeypatch.setattr(prom.ch, "questionary", Q)
    monkeypatch.setattr(builtins, "input", lambda prompt="": "fallback")
    assert prom.ask_text("p", default="d") == "fallback"


def test_ask_text_non_tty_returns_default(monkeypatch):
    # Simulate sys.stdin.isatty raising exception and not in test env
    # Ensure orchestrator TUI mode does not interfere with this test by
    # installing a lightweight dummy module into sys.modules so the
    # local import inside `ask_text` resolves to a non-TUI stub.
    import importlib

    pkg = importlib.import_module("src.setup.pipeline")
    stub = SimpleNamespace(_TUI_MODE=False, _TUI_UPDATER=None)
    monkeypatch.setattr(pkg, "orchestrator", stub, raising=False)
    monkeypatch.setitem(sys.modules, "src.setup.pipeline.orchestrator", stub)
    monkeypatch.setattr(prom.ch, "_HAS_Q", False)
    monkeypatch.delenv("PYTEST_CURRENT_TEST", raising=False)

    class FakeStdin:
        def isatty(self):
            raise Exception("nope")

    monkeypatch.setattr(prom, "sys", prom.sys)
    monkeypatch.setattr(prom.sys, "stdin", FakeStdin())
    assert prom.ask_text("p", default="DD") == "DD"
### END ORIGINAL: tests/setup/ui/test_prompts_unit.py
### BEGIN ORIGINAL: tests/setup/ui/test_prompts_extra_unit.py
def test_ask_confirm_with_questionary(monkeypatch):
    """When questionary is available the confirm adapter should be used."""
    class Q:
        @staticmethod
        def confirm(prompt, default=True):
            return SimpleNamespace(ask=lambda: True)

    import importlib

    pkg = importlib.import_module("src.setup.pipeline")
    stub = SimpleNamespace(_TUI_MODE=False, _TUI_UPDATER=None)
    monkeypatch.setattr(pkg, "orchestrator", stub, raising=False)
    monkeypatch.setitem(sys.modules, "src.setup.pipeline.orchestrator", stub)
    monkeypatch.setattr(prom.ch, "_HAS_Q", True)
    monkeypatch.setattr(prom.ch, "questionary", Q)
    assert prom.ask_confirm("?") is True


def test_ask_select_fallback_on_eof(monkeypatch):
    """ask_select should return the last choice when input fails."""
    monkeypatch.setattr(prom.ch, "_HAS_Q", False)
    monkeypatch.setattr(prom.ch, "questionary", None)
    monkeypatch.setattr(builtins, "input", lambda prompt="": (_ for _ in ()).throw(EOFError()))
    choices = ["A", "B"]
    assert prom.ask_select("x", choices) == "B"
### END ORIGINAL: tests/setup/ui/test_prompts_extra_unit.py

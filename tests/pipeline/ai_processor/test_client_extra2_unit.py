"""Consolidated unit tests for src.src/pipeline/ai_processor/client.py

This file was autogenerated by a repository consolidation script.
Original test files:
 - tests/pipeline/ai_processor/test_client_unit.py
 - tests/pipeline/ai_processor/test_client_extra2_unit.py
 - tests/pipeline/ai_processor/test_client_extra_unit.py
 - tests/pipeline/ai_processor/test_client_more_unit.py
"""

import asyncio
import json
from types import SimpleNamespace

import aiohttp
import pytest

from src.pipeline.ai_processor.client import AIAPIClient


class DummyResponse:
    def __init__(self, status: int, text_value: str):
        self.status = status
        self._text = text_value

    async def text(self) -> str:
        return self._text

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return False


class DummySession:
    def __init__(self, response: DummyResponse | Exception):
        self.response = response

    def post(self, *a, **k):
        if isinstance(self.response, Exception):
            raise self.response
        return self.response


@pytest.mark.asyncio
async def test_missing_endpoint_returns_config_error() -> None:
    """Return a configuration error tuple when endpoint is absent.

    The client should not attempt any network activity when the endpoint
    is not configured.
    """
    cfg = SimpleNamespace(gpt4o_endpoint="", api_key="x")
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(None, {})
    assert ok is False
    assert cleaned is None
    assert raw is not None and raw.get("error_type") == "ConfigurationError"


@pytest.mark.asyncio
async def test_json_decode_error_returns_raw_text() -> None:
    """When the server returns invalid JSON, the raw text is exposed."""
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(DummyResponse(200, "not-a-json"))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {"a": 1})
    assert ok is False
    assert cleaned is None
    assert raw == {"raw_response_text": "not-a-json"}


@pytest.mark.asyncio
async def test_success_with_fenced_code_strips_backticks() -> None:
    """Content wrapped in fenced code blocks should be unwrapped."""
    payload = {"choices": [{"message": {"content": "```py\nhello\n```"}}]}
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(DummyResponse(200, json.dumps(payload)))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is True
    assert cleaned == "hello"
    assert isinstance(raw, dict) and "choices" in raw


@pytest.mark.asyncio
async def test_empty_choices_retries_and_returns_false(monkeypatch) -> None:
    """Empty `choices` should cause retries and ultimately a False result."""
    payload = {"choices": []}
    cfg = SimpleNamespace(
        gpt4o_endpoint="http://x", api_key="k", max_retries=1, backoff_factor=0
    )
    session = DummySession(DummyResponse(200, json.dumps(payload)))
    client = AIAPIClient(cfg)

    # Make sleeps no-ops to keep the test fast. Patch with an async
    # no-op to avoid recursive calls to `asyncio.sleep` which would
    # otherwise cause infinite recursion and blow up memory.
    async def _noop_sleep(*_args, **_kwargs):
        return None

    monkeypatch.setattr(asyncio, "sleep", _noop_sleep)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is False
    assert cleaned is None
    assert raw == payload


@pytest.mark.asyncio
async def test_clienterror_handling_returns_error_object() -> None:
    """Network errors from aiohttp should be reported as ClientError."""
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(aiohttp.ClientError("boom"))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is False
    assert cleaned is None
    assert raw is not None and raw.get("error_type") == "ClientError"

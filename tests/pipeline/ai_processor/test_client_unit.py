"""Consolidated unit tests for src.src/pipeline/ai_processor/client.py

This file was autogenerated by a repository consolidation script.
Original test files:
 - tests/pipeline/ai_processor/test_client_unit.py
 - tests/pipeline/ai_processor/test_client_extra2_unit.py
 - tests/pipeline/ai_processor/test_client_extra_unit.py
 - tests/pipeline/ai_processor/test_client_more_unit.py
"""

import json
from types import SimpleNamespace

import aiohttp
import asyncio
import pytest

from src.pipeline.ai_processor.client import AIAPIClient


class DummyResponse:
    def __init__(self, status: int, text_value: str):
        self.status = status
        self._text = text_value

    async def text(self):
        return self._text

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return False


class DummySession:
    def __init__(self, resp: object | Exception):
        self.resp = resp

    def post(self, *a, **k):
        if isinstance(self.resp, Exception):
            raise self.resp
        return self.resp


@pytest.mark.asyncio
async def test_no_endpoint_returns_config_error():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="")
    client = AIAPIClient(cfg)
    ok, content, data = await client.process_content(None, {})
    assert ok is False
    assert content is None
    assert data.get("error_type") == "ConfigurationError"


@pytest.mark.asyncio
async def test_http_200_invalid_json_returns_raw_text():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0)
    client = AIAPIClient(cfg)
    resp = DummyResponse(200, "not-json")
    session = DummySession(resp)
    ok, content, data = await client.process_content(session, {"foo": "bar"})
    assert ok is False
    assert content is None
    assert data.get("raw_response_text") == "not-json"


@pytest.mark.asyncio
async def test_http_200_with_fenced_content_is_cleaned():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x")
    client = AIAPIClient(cfg)
    payload = {"choices": [{"message": {"content": "```markdown\nHello\n```"}}]}
    resp = DummyResponse(200, json.dumps(payload))
    session = DummySession(resp)
    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Hello"


@pytest.mark.asyncio
async def test_clienterror_returns_clienterror_type():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0)
    client = AIAPIClient(cfg)
    session = DummySession(aiohttp.ClientError("boom"))
    ok, content, data = await client.process_content(session, {})
    assert ok is False
    assert data.get("error_type") == "ClientError"


@pytest.mark.asyncio
async def test_retry_on_clienterror_then_success(monkeypatch):
    cfg = SimpleNamespace(
        api_key="k", gpt4o_endpoint="http://x", max_retries=1, backoff_factor=0.1
    )
    client = AIAPIClient(cfg)

    payload = {"choices": [{"message": {"content": "Hi"}}]}

    # Create a session that raises ClientError on first call and succeeds
    class SeqSession:
        def __init__(self, seq):
            self.seq = list(seq)

        def post(self, *a, **k):
            item = self.seq.pop(0)
            if isinstance(item, Exception):
                raise item
            return item

    seq = [aiohttp.ClientError("boom"), DummyResponse(200, json.dumps(payload))]
    session = SeqSession(seq)

    async def _noop_sleep(*a, **k):
        return None

    monkeypatch.setattr(asyncio, "sleep", _noop_sleep)

    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Hi"


@pytest.mark.asyncio
async def test_429_then_success_retries(monkeypatch):
    cfg = SimpleNamespace(
        api_key="k", gpt4o_endpoint="http://x", max_retries=1, retry_sleep_on_429=0.01
    )
    client = AIAPIClient(cfg)

    payload = {"choices": [{"message": {"content": "Ok"}}]}

    class SeqSession:
        def __init__(self, seq):
            self.seq = list(seq)

        def post(self, *a, **k):
            return self.seq.pop(0)

    seq = [DummyResponse(429, ""), DummyResponse(200, json.dumps(payload))]
    session = SeqSession(seq)

    async def _noop_sleep(*a, **k):
        return None

    monkeypatch.setattr(asyncio, "sleep", _noop_sleep)

    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Ok"


@pytest.mark.asyncio
async def test_timeout_then_success(monkeypatch):
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=1)
    client = AIAPIClient(cfg)

    payload = {"choices": [{"message": {"content": "Done"}}]}

    class SeqSession:
        def __init__(self, seq):
            self.seq = list(seq)

        def post(self, *a, **k):
            item = self.seq.pop(0)
            if isinstance(item, Exception):
                raise item
            return item

    seq = [TimeoutError(), DummyResponse(200, json.dumps(payload))]
    session = SeqSession(seq)

    async def _noop_sleep(*a, **k):
        return None

    monkeypatch.setattr(asyncio, "sleep", _noop_sleep)

    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Done"


@pytest.mark.asyncio
async def test_unmatched_fenced_block_is_stripped():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x")
    client = AIAPIClient(cfg)
    payload = {"choices": [{"message": {"content": "```Hello"}}]}
    resp = DummyResponse(200, json.dumps(payload))
    session = DummySession(resp)
    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Hello"

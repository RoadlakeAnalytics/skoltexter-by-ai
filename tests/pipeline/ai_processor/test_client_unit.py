"""Consolidated unit tests for src.src/pipeline/ai_processor/client.py

This file was autogenerated by a repository consolidation script.
Original test files:
 - tests/pipeline/ai_processor/test_client_unit.py
 - tests/pipeline/ai_processor/test_client_extra2_unit.py
 - tests/pipeline/ai_processor/test_client_extra_unit.py
 - tests/pipeline/ai_processor/test_client_more_unit.py
"""


import json
import asyncio
import aiohttp
from types import SimpleNamespace
import pytest
from src.pipeline.ai_processor.client import AIAPIClient

### BEGIN ORIGINAL: tests/pipeline/ai_processor/test_client_unit.py
class DummyResponse:
    def __init__(self, status: int, text_value: str):
        self.status = status
        self._text = text_value

    async def text(self):
        return self._text

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return False


class DummySession:
    def __init__(self, resp: object | Exception):
        self.resp = resp

    def post(self, *a, **k):
        if isinstance(self.resp, Exception):
            raise self.resp
        return self.resp


@pytest.mark.asyncio
async def test_no_endpoint_returns_config_error():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="")
    client = AIAPIClient(cfg)
    ok, content, data = await client.process_content(None, {})
    assert ok is False
    assert content is None
    assert data.get("error_type") == "ConfigurationError"


@pytest.mark.asyncio
async def test_http_200_invalid_json_returns_raw_text():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0)
    client = AIAPIClient(cfg)
    resp = DummyResponse(200, "not-json")
    session = DummySession(resp)
    ok, content, data = await client.process_content(session, {"foo": "bar"})
    assert ok is False
    assert content is None
    assert data.get("raw_response_text") == "not-json"


@pytest.mark.asyncio
async def test_http_200_with_fenced_content_is_cleaned():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x")
    client = AIAPIClient(cfg)
    payload = {"choices": [{"message": {"content": "```markdown\nHello\n```"}}]}
    resp = DummyResponse(200, json.dumps(payload))
    session = DummySession(resp)
    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "Hello"


@pytest.mark.asyncio
async def test_clienterror_returns_clienterror_type():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0)
    client = AIAPIClient(cfg)
    session = DummySession(aiohttp.ClientError("boom"))
    ok, content, data = await client.process_content(session, {})
    assert ok is False
    assert data.get("error_type") == "ClientError"
### END ORIGINAL: tests/pipeline/ai_processor/test_client_unit.py
### BEGIN ORIGINAL: tests/pipeline/ai_processor/test_client_extra2_unit.py
class DummyResponse:
    def __init__(self, status: int, text_value: str):
        self.status = status
        self._text = text_value

    async def text(self) -> str:
        return self._text

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return False


class DummySession:
    def __init__(self, response: DummyResponse | Exception):
        self.response = response

    def post(self, *a, **k):
        if isinstance(self.response, Exception):
            raise self.response
        return self.response


@pytest.mark.asyncio
async def test_missing_endpoint_returns_config_error() -> None:
    """Return a configuration error tuple when endpoint is absent.

    The client should not attempt any network activity when the endpoint
    is not configured.
    """
    cfg = SimpleNamespace(gpt4o_endpoint="", api_key="x")
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(None, {})
    assert ok is False
    assert cleaned is None
    assert raw is not None and raw.get("error_type") == "ConfigurationError"


@pytest.mark.asyncio
async def test_json_decode_error_returns_raw_text() -> None:
    """When the server returns invalid JSON, the raw text is exposed."""
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(DummyResponse(200, "not-a-json"))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {"a": 1})
    assert ok is False
    assert cleaned is None
    assert raw == {"raw_response_text": "not-a-json"}


@pytest.mark.asyncio
async def test_success_with_fenced_code_strips_backticks() -> None:
    """Content wrapped in fenced code blocks should be unwrapped."""
    payload = {"choices": [{"message": {"content": "```py\nhello\n```"}}]}
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(DummyResponse(200, json.dumps(payload)))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is True
    assert cleaned == "hello"
    assert isinstance(raw, dict) and "choices" in raw


@pytest.mark.asyncio
async def test_empty_choices_retries_and_returns_false(monkeypatch) -> None:
    """Empty `choices` should cause retries and ultimately a False result."""
    payload = {"choices": []}
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=1, backoff_factor=0)
    session = DummySession(DummyResponse(200, json.dumps(payload)))
    client = AIAPIClient(cfg)

    # Make sleeps no-ops to keep the test fast. Patch with an async
    # no-op to avoid recursive calls to `asyncio.sleep` which would
    # otherwise cause infinite recursion and blow up memory.
    async def _noop_sleep(*_args, **_kwargs):
        return None

    monkeypatch.setattr(asyncio, "sleep", _noop_sleep)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is False
    assert cleaned is None
    assert raw == payload


@pytest.mark.asyncio
async def test_clienterror_handling_returns_error_object() -> None:
    """Network errors from aiohttp should be reported as ClientError."""
    cfg = SimpleNamespace(gpt4o_endpoint="http://x", api_key="k", max_retries=0)
    session = DummySession(aiohttp.ClientError("boom"))
    client = AIAPIClient(cfg)
    ok, cleaned, raw = await client.process_content(session, {})
    assert ok is False
    assert cleaned is None
    assert raw is not None and raw.get("error_type") == "ClientError"
### END ORIGINAL: tests/pipeline/ai_processor/test_client_extra2_unit.py
### BEGIN ORIGINAL: tests/pipeline/ai_processor/test_client_extra_unit.py
class SeqResponse:
    def __init__(self, session):
        self._session = session

    async def __aenter__(self):
        status, text = self._session.seq.pop(0)
        self.status = status
        self._text = text

        async def textfn():
            return self._text

        self.text = textfn
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return False


class SeqSession:
    def __init__(self, seq):
        # operate on a mutable list so SeqResponse instances consume it
        self.seq = list(seq)

    def post(self, *a, **k):
        return SeqResponse(self)


@pytest.mark.asyncio
async def test_429_then_success_retry():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=1, backoff_factor=0, retry_sleep_on_429=0)
    client = AIAPIClient(cfg)
    # First response 429, then a successful 200 with valid content
    good = {"choices": [{"message": {"content": "OK"}}]}
    seq = [(429, "rate"), (200, json.dumps(good))]
    session = SeqSession(seq)
    ok, content, data = await client.process_content(session, {})
    assert ok is True
    assert content == "OK"


@pytest.mark.asyncio
async def test_choices_not_list_returns_data():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0)
    client = AIAPIClient(cfg)
    payload = {"choices": "bad"}
    session = SeqSession([(200, json.dumps(payload))])
    ok, content, data = await client.process_content(session, {})
    assert ok is False
    assert isinstance(data, dict)
### END ORIGINAL: tests/pipeline/ai_processor/test_client_extra_unit.py
### BEGIN ORIGINAL: tests/pipeline/ai_processor/test_client_more_unit.py
class Resp:
    def __init__(self, status, text):
        self.status = status
        self._text = text

    async def text(self):
        return self._text

    async def __aenter__(self):
        return self

    async def __aexit__(self, *a):
        return False


class Sess:
    def __init__(self, resp):
        self.resp = resp

    def post(self, *a, **k):
        return self.resp


@pytest.mark.asyncio
async def test_http_500_then_fail_no_retry():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0, backoff_factor=0)
    client = AIAPIClient(cfg)
    payload = {}
    session = Sess(Resp(500, "err body"))
    ok, content, data = await client.process_content(session, payload)
    assert ok is False
    assert data.get("status_code") == 500 or data.get("error_body") == "err body"


@pytest.mark.asyncio
async def test_timeout_error_branch():
    cfg = SimpleNamespace(api_key="k", gpt4o_endpoint="http://x", max_retries=0, backoff_factor=0)
    client = AIAPIClient(cfg)

    class BadSess:
        def post(self, *a, **k):
            raise TimeoutError()

    ok, content, data = await client.process_content(BadSess(), {})
    assert ok is False
    assert data.get("error_type") in ("TimeoutError", "Exception")
### END ORIGINAL: tests/pipeline/ai_processor/test_client_more_unit.py
